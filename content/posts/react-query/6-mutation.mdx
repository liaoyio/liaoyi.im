---
title: Mutation 与乐观更新
description: 与查询不同，mutation（变更）通常用于创建 / 更新 / 删除数据或执行服务器端副作用。为此，TanStack Query 提供了 useMutation 钩子。
date: 2025-05-27
tags: ['react-query', '异步状态管理']
author: liaoyi
series: react-query
seriesPart: 6
---


## 什么是 Mutation？

所有状态管理工具本质上都是在做两件事: 一个是 `获取数据`，一个是 `修改数据`。


比如 React 中的 `useState` hook，顾名思义，它本质也是一种状态管理。

```ts
const [state, setState] = useState(initialState)
```

其中 `state` 是获取数据，`setState` 用于修改数据。


在 TanStack Query 中，数据获取由 useQuery 负责，而数据修改则由 useMutation 处理。
> 我个人理解，就是为 `POST`/`PUT`/`DELETE` 等请求提供了一个更方便的钩子。


## 使用 useMutation


```ts
const { mutate, isPending, isSuccess, isError } = useMutation({
  mutationFn: () => {
    return axios.post("/api/user", { name: "jack" })
  },
  onMutate: () => {
    console.log("开始变更")
  },
  onSuccess: () => {
    console.log("变更成功")
  },
  onError: () => {
    console.log("变更失败")
  },
  onSettled: () => {
    console.log("变更完成（成功或失败）")
  }
})
```


为什么不用 `axios.post()` 而使用 `useMutation` ?

因为`useMutation` 可以让我们更方便获取状态和拓展功能：

1. 内建状态：如 `isPending`、`isSuccess`、`isError`；
2. 自动重试机制：支持配置 `retry`；
3. 生命周期回调：可以处理 UI 提示、缓存更新等逻辑；
4. 和 `QueryClient` 紧密集成，可直接操作缓存。



<Callout type='warn' >
- 如果 `mutationFn` 中返回的 Promise 为`reject` 状态，那么就算接口请求成功了，`onSuccess` 也不会触发。
- useMutation 的 throwOnError 参数可以控制是否抛出错误，但默认是`false`
- 换句话说，如果 `onSuccess` 一直不触发，请将 throwOnError 设为 true，查看是否报错。
</Callout>

## 利用回调管理缓存

可以通过 `onSuccess`、`onError` 等回调在变更完成后更新缓存：

```tsx
const { mutate } = useMutation({
  mutationFn: () => axios.post("/api/user", { name: "jack" })
  onSuccess: (newUser) => {
    toast.success("用户创建成功");

    // 方法 1：创建用户成功后，更新缓存中的用户列表
    queryClient.setQueryData(["users", newUser.id], newUser)

    // 方法 2：创建用户成功后，让之前的缓存数据失效，并重新获取数据（即刷新缓存）
    queryClient.invalidateQueries({ queryKey: ["users"] })
  }
})
```

- `setQueryData`: 手动更新缓存；
- `invalidateQueries`: 标记为过期并重新请求。


## 乐观更新（Optimistic Updates）


正常流程：用户点击 → 显示 loading → 等待后端返回 → 更新状态 （⚠️ 用户体验很不流畅）
乐观更新：用户点击 → 立即更新 UI → 等待后端返回 → 成功则保留，失败则回滚并提示

以下这些场景非常适合使用乐观更新：

- 点赞 / 收藏
- 关注 / 取关
- 评论 / 删除
- 拖拽排序等即时 UI 响应操作

### 基础实现: onMutate + 回滚

既然是乐观更新，那就不能等后端返回结果再修改状态了。换句话说，我们不应该在 `onSuccess` 中修改状态，而是应该在 `onMutate` 中修改状态。

**怎么修改状态呢？**

- `queryClient` 提供了`setQueryData`方法，可以让我们修改缓存的数据。

**如果网络请求失败了，我们该如何回滚状态？**

- `queryClient`提供了`getQueryData`方法，可以让我们获取缓存的数据。


基于`queryKey`，我们可以在乐观的修改状态前先保存目前缓存的状态作为快照，再在 `onMutate` 方法中返回一个回滚方法。

注意：`onError` 函数的第三个参数是 context，它是`onMutate`的返回值，在本例中就是回滚方法。

类似`Promise`，该 api 还提供了`onSettled`，它无论接口成功与否，都会执行。我们可以在里面调用`invalidateQueries`，刷新缓存。



```tsx
onMutate: async ({ targetData }) => {
  const snapshot = queryClient.getQueryData(queryKey)

  // 乐观更新
  queryClient.setQueryData(queryKey, (oldData) => {
    return newData;
  })

  // 返回一个回滚函数
  return () => queryClient.setQueryData(queryKey, snapshot)
},

onError: (err, variables, rollback) => {
  rollback?.()
},

onSettled: () => {
  queryClient.invalidateQueries({ queryKey })
}
```


## 真实案例：Todo 勾选切换


```tsx
const useCheckTodo = () => {
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: ({ todo }: { todo: Todo }) => checkTodo(todo),
    onMutate: ({ todo }) => {
      const snapshot = queryClient.getQueryData(["todoList"])

      queryClient.setQueryData(["todoList"], (oldData: Todo[]) =>
        oldData.map((t) =>
          t.id === todo.id ? { ...t, completed: !t.completed } : t
        )
      )

      return () => queryClient.setQueryData(["todoList"], snapshot)
    },

    onError: (error, todo, rollback) => {
      rollback?.()
    },

    onSettled: () => {
      queryClient.invalidateQueries({ queryKey: ["todoList"] })
    }
  })
}
```


### 封装通用 Hook

若你项目中多次使用乐观更新，可以封装一个统一的 Hook。

> 但我觉得一个项目中涉及到乐观更新的地方其实并不多，基于 `useMutate` 调用`onMutate`，`onError`，`onSettled` 等方法，可以很方便的实现乐观更新。封装了 Hook 后，反而增加了代码的复杂度。

```tsx

type UseOptimisticMutationParams<TData = unknown> = {
  mutationFn: MutationFunction<TData, any>
  queryKey: QueryKey
  updater: (oldData: any) => any
  invalidates?: QueryKey
};

export const useOptimisticMutation = <TData>({
  mutationFn,
  queryKey,
  updater,
  invalidates = queryKey,
}: UseOptimisticMutationParams<TData>) => {
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn,
    onMutate: async () => {
      // 取消任何相关请求，避免覆盖结果
      await queryClient.cancelQueries({ queryKey })

      const snapshot = queryClient.getQueryData(queryKey)
      queryClient.setQueryData(queryKey, updater)

      return () => queryClient.setQueryData(queryKey, snapshot)
    },
    onError: (err, variables, rollback) => {
      rollback?.()
    },
    onSettled: () => {
      queryClient.invalidateQueries({ queryKey: invalidates })
    }
  })
}
```